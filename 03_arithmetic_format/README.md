# C 프로그래밍 학습: 산술형식

## 정수 산술 형식


### 정수

정수형식 : 유한 범위의 정수를 표현
- 부호있는 정수 형식 : 양의 정수, 0, 음의정수
- 부호없는 정수 형식 : 양의 정수, 0

정수범위 : 구현체에 따라 달라짐

정수 개체의 값 : 개체에 할당된 스토리지의 비트에 특정 인코딩으로 표현




### 패딩과 정밀도

패딩(Padding)
- 하드웨어 최적화
- cpu에서 데이터를 16비트 단위로 처리한다면 13비트 정수 처리시 3비트는 비워두고 건너는게 빠름(하드웨어 쿼크)
- 패딩 비트 : 값을 표현하지 않는 여분의 비트
- char, signed char, unsigned char를 제외한 모든 정수 형식에 패딩비트가 포함될 수 있음

너비(Width) : N
- 형식의 값을 표현하기 위해 사용되는 비트 수, 패딩을 제외, 부호 포함
- ``` singed int ``` 16비트로 저장시
  - 1비트는 부호 비트
  - 3비트는 패딩 비트
  - 12비트는 진짜 값
  - 너비 = 1(부호) + 12(값) = 13비트

정밀도(Precision)
- 부호와 패딩 비트 모두를 제외한 값을 표현하기 위해 사용되는 비트 수
- 위의 예시에서 정밀도 = 12비트



### 정수 선언
```c
unsigned int ui;   // unsigned 필요
unsigned u;        // int 생략 가능
unsigned long long ull2;  // int 생략 가능
unsigned char uc; // unsigned 필요
```
- 부호 있는 정수 형식 선언시 signed 키워드 생략 가능
- 일반 char와 signed char를 구별하기 위해 signed char는 예외
- long long int 등  int 생략 가능

```c
int i;
long long int sll;
long long sll2;
signed char sc;
```



### 부호 없는 정수
`unsigned int`, `unsigned short`, `unsigned char` 등은 **음수를 표현하지 않는 정수형 타입**

- 오직 **0 이상의 값만 표현**
- 예:
  - `unsigned char` (8비트): 0 ~ 255
  - `unsigned int` (32비트): 0 ~ 4,294,967,295

- 부호가 없기 때문에, 모든 비트를 **값을 표현하는 데** 사용
- `signed`와 `unsigned`끼리 연산하면 **예상치 못한 결과**
  예: `if (-1 < 1U)`는 false (왜냐면 -1이 unsigned로 변환되면 엄청 큰 수가 됨)


| 타입                      | 최소 크기 (바이트) | 비트 수 (최소) | 최대값 (`<limits.h>`)        | 표현식                                 |
|---------------------------|--------------------|----------------|-------------------------------|-----------------------------------------|
| `unsigned char`           | 1                  | 8              | `UCHAR_MAX` = 255             | 2⁸ − 1                                  |
| `unsigned short`          | 2                  | 16             | `USHRT_MAX` = 65,535          | 2¹⁶ − 1                                 |
| `unsigned int`            | 4                  | 16 (최소) <br>32 (보통) | `UINT_MAX` = 4,294,967,295    | 2³² − 1 (x86 일반 환경)                 |
| `unsigned long`           | 4 (x86) <br> 8 (x64) | 32 또는 64     | `ULONG_MAX` = 4,294,967,295 (x86) <br> 18,446,744,073,709,551,615 (x64) | 2³² − 1 또는 2⁶⁴ − 1                    |
| `unsigned long long`      | 8                  | 64             | `ULLONG_MAX` = 18,446,744,073,709,551,615 | 2⁶⁴ − 1                        |



### 랩어라운드(wraparound)
- 부호 없는 정수 형식에서 표현하기에 너무 작거나(0보다 작은) 너무 큰(2^n-1) 값이 산술 연산의 결과 나올 때 발생
- 부호 없는 정수는 이진수로 저장되며, 비트 수는 고정입니다.
- unsigned char에서 255 + 1 → 256인데, 8비트로는 표현 불가 → 하위 8비트만 남기면 00000000 → 0 (랩어라운드)
- 정의된 동작임, 하지만 부호있는 정수에선는 정의되지 않는 동작임
- 순환 버퍼 인덱스 관리, 타이머 오버플로우 감지, 시퀸스 번호 비교에 사용됨
```c
#include <limits.h>
unsigned int ui = UINT_MAX;
ui++;
printf("ui = %d\n", ui);  // ui = 0
ui--;
printf("ui = %d\n", ui);  // ui = 4,294,967,295
```

```c
for(unsigned int i = n; i >= 0; --i)  // 랩어라운드로 정수 표현은 절때 0보다 작을 수 없다, 루프에서 벗어나지 못함
```

```c
extern unsigned int ui, sum;
if(sum + ui > UINT_MAX) // 오버 플로우를 체크하려다가 오버플로우한 값을 비교하고 있음 절대 too_big()이 동작하지 않음
  too_big();
else
  sum = sum + ui;
```
```c
extern unsigned int ui, sum;
if(ui > UINT_MAX - sum)   // 오버플로우 발생 전 비교(정상)
  too_big();
else
  sum = sum + ui;
```

```c
// GCC, Clang에서 지원하는 오버플로우 감지 내장 함수
// bool _builtin_add_overflow(type a, type b, type *result);
// bool _builtin_sub_overflow(type a, type b, type *result);
// bool _builtin_mul_overflow(type a, type b, type *result);
// a,b : 더할 두 정수
// result : 결과를 저장할 변수의 포인터
// 반환값 : true 오버플로우, false 정상

#include <stdio.h>
#include <stdbool.h>

int main() {
    unsigned int a = 4000000000;
    unsigned int b = 500000000;

    unsigned int result;
    if (__builtin_add_overflow(a, b, &result)) {
        printf("오버플로우 발생!\n");
    } else {
        printf("덧셈 결과: %u\n", result);
    }

    return 0;
}
```
```c
extern unsigned int i, j;
if(i - j < 0)   // 오버플로우 이후에 오버플로우 검사
  negative();
else
  i = i - j;
```
```c
extern unsigned int i, j;
if(i > j)   // 먼저 오버플로우 검사(정상)
  negative();
else
  i = i - j;
```



### 부호 있는 정수
#### 표현
- 부호와 크기(sign-magnitude)
  - MSB를 부호 비트로 사용 (0: 양수, 1: 음수)
  - ```0000 0101``` = 5, ```1000 0101``` = -5
  - 연산이 복잡함
  - +0, -0 존재
- 1의 보수(ones' complement)
  - 음수를 표현할 때 비트를 반전해서 사용
  - 양수는 그대로
  - 음수는 각 비트를 반전(not)해서 표현
  - ```0000 0101``` = 5, ```1111 1010``` = -5
  - +0, -0 존재
  - 덧셈시 캐리 복원이 필요함
- 2의 보수(two's complement)
  - 양수는 그대로 저장
  - 음수는 1의 보수 +1해서 표현
  - ```0000 0101``` = 5, ```1111 1011``` = -5
  - 0은 유일 ```0000 0000```
  - 덧셈/뺼셈이 동일 회로로 가능


#### 표현 가능한 값의 개수
- **기준 환경**: 일반적인 x86/x86_64 환경 (GCC, Clang, LP64 모델)
- **표현 방식**: `2의 보수` 방식 (현대 컴퓨터에서 표준)
- `n`비트일 때 표현 범위는:
  - 총 개수 = 2^n
  - 양수 개수 = `2ⁿ⁻¹ - 1`
  - 0
  - 음수 개수 = `2ⁿ⁻¹`


#### 부호 있는 정수형 범위 표 (`<limits.h>` 기준)

| 타입                   | 바이트 수 | 비트 수 | 최소값 (`*_MIN`)       | 최대값 (`*_MAX`)       | 표현 범위                      |
|------------------------|------------|----------|--------------------------|--------------------------|--------------------------------|
| `signed char`          | 1          | 8        | `-128`                  | `127`                   | `-2⁷` ~ `2⁷ - 1`             |
| `short` / `signed short` | 2          | 16       | `-32,768`               | `32,767`                | `-2¹⁵` ~ `2¹⁵ - 1`           |
| `int` / `signed int`   | 4          | 32       | `-2,147,483,648`        | `2,147,483,647`         | `-2³¹` ~ `2³¹ - 1`           |
| `long` / `signed long` | 4 (x86)    | 32       | `-2,147,483,648`        | `2,147,483,647`         | `-2³¹` ~ `2³¹ - 1`           |
|                        | 8 (x64)    | 64       | `-9,223,372,036,854,775,808` | `9,223,372,036,854,775,807` | `-2⁶³` ~ `2⁶³ - 1`   |
| `long long` / `signed long long` | 8 | 64 | `-9,223,372,036,854,775,808` | `9,223,372,036,854,775,807` | `-2⁶³` ~ `2⁶³ - 1`   |

- 시각적 예 (8비트 signed)

```
[ 음수영역 ]
10000000 (-128)  ~  11111111 (-1)

[양수 영역]
00000000 (0)      ~  01111111 (127)
```



### 오버플로우(overflow)
- 부호가 있는 정수 연산 결과가 결과 형식으로 표현할 수 없을 때 발생
- 정의 되지 않은 동작

```c
#define Abs(i) ((i) < 0 ? -(i): i)
signed int si = -25;
signed int abs_si = Abs(si)
printf("%d\n",abs_si);

signed int sim = INT_MIN;
signed int abs_sim = Abs(sim) // 음수 쪽이 양수보다 1크기 때문 즉 -INT_MIN은 표현 불가 -> 오버플로우 발생(정의되지 않은 동작)
printf("%d\n",abs_sim);
```
- 재네릭 형식 : 함수와 유사한 매크로, 모든 형식의 인수를 입력 받을 수 있다.
- 래핑 : 값이 최대치를 넘으면 다시 최솟값부터 순환
- 트랩 : 실행 중 예외를 발생시켜 프로그램을 중단
- 정의되지 않은 동작 발생시 래핑 또는 트랩을 컴파일러가 발생시킴

```c
#define AbsM(i, flag) ((i) >= 0 ? (i) : ((i) == (flag) ? (flag) : -(i)))  // 형식 종속 플래그
signed int si = -25;
signed int abs_si = AbsM(si, INT_MIN);

if(abs_si == INT_MIN)
  goto recover;
else
  printf("%d\n", abs_si);
```


### 정수 상수
- 정수 상수(integer constant), 정수 리터럴(integer literal)은 특정 정수값을 적용하기 위해 사용하는 상수
- 10진수 : 0이 아닌 숫자로 시작
- 8진수 : 0으로 시작 후 0부터 7사이의 숫자가 뒤에 오는 경우
- 16진수 : 0x, 0X로 시작후 10진수와 a~f 문자로 된 경우
- 상수에 접미사를 부텨 상수의 형식을 지정할 수 있음(U, L, LL)
- 접미사를 사용하지 않을 경우 정수 상수가 필요한 타입과 일치 하지 않는다면 암시적으로 변환됨
```c
unsigned int ui = 71U;
signed long int sli  = 1230498092349L;
unsigned long long int ui = 019834109238401ULL;
```


## 부동 소수점

- floating_point, 실수를 표현, 과학적 표기법을 사용 숫자를 밑수와 지수로 인코딩
- c 표준에서 구현체가 특정 모델을 사용해야한다고 명시하진 않지만 구현체가 지원해야 하는 모델을 명시함

### 부동 소수점 형식
- float
  - 단정밀도(single-precision) 계산 사용, 1개의 부호 비트와 8개의 지수 비트, 그리고 23개의 유효 비트로 구성
  - 양의 최대값 ```3.4 × 10³⁸```
  - 양의 최소 정규값 ```1.18 × 10⁻³⁸```
  - 정밀도 7자리 십진수 정확도

- double
  - 배정밀도(double-precision), 1개 부호비트, 11개의 지수 비트, 52개의 유효비트
  - 양의 최대값 1.8 × 10³⁰⁸
짐짐
- long double
  - 확장정밀도
  - 양의 최대값 대략 1e+4932이상

### 부도 소수점 산술
- floating point arithmetic
- 숫자의 크기가 유계(bounded), 유한 정밀도(finite precision)
  - 표현 가능한 숫자의 범위는 유한, 표현가능한 정밀도 또한 유한함
- 덧셈과 곱셈 연산은 결합성이 성립되지 않으며, 분배법칙도 적용되지 않음
  - ```(a + b) + c``` =! ```a + (b + c)```
  - ```a*(b + c)``` =! ```a*b + a*c```
  - 연산 시 오차 누적이 다르게 일어남
  - 반올림이 연산 순서에 따라 달라짐
- 일반적인 십진수 상수는 이진 부동 소수점 숫자로 정확하게 표현할 수 없다. CERT C 규칙
  - 0.1, 0.2, 1.3 등 2진수로 무한 소수가 되어 정확히 표현 안됨
  - 컴파일 타임에 소수 리터럴은 내부적으로 근사치로 변환

좋아요! 주신 키워드를 바탕으로 **부동소수점 연산(floating-point arithmetic)**의 핵심 개념과 **CERT C 규칙** 관점에서의 주의사항을 정리해드릴게요.

#### ⚠️ 4. **CERT C 규칙 관련 사항**

| ID | 규칙 / 권고 | 요약 설명 |
|----|-------------|------------|
| **FLP30-C** | 부동소수점 비교 시 오차 감안 | `if (x == y)` 대신 오차 범위 고려 |
| **FLP32-C** | 정수와 부동소수점 간의 변환에 주의 | 정밀도 손실, 오버플로우 주의 |
| **FLP34-C** | 표현 가능한 값 범위 내에서만 연산 수행 | underflow/overflow 방지 |p
| **FLP37-C** | 부동소수점 연산 순서에 따라 값이 달라질 수 있음 | 연산 순서를 명확히 하라 |
| **FLP13-C** | NaN이나 무한대에 대한 체크 필요 | 특수 값으로 인한 예외처리 필요 |

### 부동 소수점 값
- 유효 비트, 암시적으로 생략된 맨 앞의 1도 값의 일부로 간주
- 0를 나타내기 위해 지수와 유효 비트는 모두 0, 부호 비트에 따라 -0, +0 존재
- 비정규화된 숫자 , 정규화된 숫자는 표현 할 수 이쓴ㄴ 가장 작은 값보다 작은 지수를 나타내는 매우 작은 양수와 음수로 0은 아니다.
- 최소 지수로 표현되는 0이 아닌 숫자는 명시적 유효 비트가 모두 1이더라도 준정규 숫자다
- 비정규화된 부동 소수점 값의 정밀도는 정규화된 부동 소수점 값의 정밀도 보다 낮다
- 부동 소수점 형식은 음의 무한대와 양의 무한대, 부동 소수점 숫자가 아닌 값을 표현하는데 사용할 수 있다.
- NaN은 실수가 아닌 값이다.
- 무한대를 특수한 값으로 사용할 수 있게 되면 위의 오버플로우 상황에서도 연산을 계속할 수 있다.
- 0이 아닌 양수나 음수를 +0이나 -0으로 나누면 양의 무한대나 음의 무한대가 된다.
- 자동 NaN은 거의 모든 산술 연산에 대해 부동 소수점 예외를 발생하지 않는다.
- 신호NaN은 산술 피연산자로 사용될 때 즉시 부동 소수점 예외가 발생
- 부동 소수점 값의 종류를 확인 하는 방법
```c
#include <math.h>
int fpclassify(real-floating x);
const char *show_classification(double x)
{
  switch(fpclassify(x))
  {
      case FP_INFINTE: return "Inf";
      case
  }
}
```
