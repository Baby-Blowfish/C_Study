# 1장 프로그램 만들기

# 1-1 프로그램과 C언어

## C 언어의 탄생

프로그래밍 언어 : 컴퓨터가 이해할 수 있는, 정확한 표현의 규칙을 정의해 놓은 것

C언어는 1972년 벨 연구소의 **데니스 리치(Dennis Ritchie)**에 의해 개발 C언어는 유닉스 운영체제를 구현하기 위해 만들어졌으며, 기존의 B언어를 개선하여 더 효율적이고 강력한 기능을 제공

초기의 유닉스는 대부분 어셈블리어로 작성되어 하드웨가 바뀌면 유닉스를 다시 개발해야 하는 문제 →  **하드웨어와 상관없이 사용할 수 있는 고수준 언어로서 하드웨어에 가까운 저수준 프로그래밍도 가능**하게됨

## C언어의 장점

1. **시스템 프로그래밍 가능**
    
    C언어는 운영체제, 컴파일러, 그리고 임베디드 시스템과 같은 시스템 소프트웨어를 프로그래밍하는 데 적합
    
    예를 들어, 메모리 관리나 입출력 장치 제어와 같은 작업을 효율적으로 수행 가능
    
2. **이식성을 갖춘 프로그램을 만들 수 있음**
    
    표준을 지켜 프로그램을 만들면 한 플랫폼에서 개발된 소프트웨어를 다른 플랫폼으로 쉽게 이식할 수 있어, 코드의 재사용성과 유지보수성을 높일 수 있음
    
3. **함수를 사용해 개별 프로그래밍이 가능**
    
    C언어는 함수 단위로 코드를 분할하여 작성할 수 있는 구조적 프로그래밍(복잡한 프로그램을 작은 단위로 나누어 개발)을 지원
    

## 생산성

### 구조적 프로그래밍 기법

구조적 프로그래밍은 코드의 흐름을 제어하기 위해 순차적, 선택적, 반복적 구조를 사용하는 기법

- 데이터와 알고리즘을 분리하여 작성
- 함수 단위로 코드를 작성하여 모듈화
- 사용 예: C 언어

### 객체지향 프로그래밍 기법

객체지향 프로그래밍은 데이터와 그 데이터를 조작하는 알고리즘을 하나의 객체로 묶어 사용하는 기법

- 데이터와 알고리즘을 클래스(객체)로 묶어서 작성
- 상속, 다형성, 캡슐화 등의 원칙을 사용
- 사용 예: C++ 언어

### 프로그램

프로그램은 데이터를 처리하는 알고리즘(로직)으로 구성됩니다. 데이터를 입력받아 처리하고, 결과를 출력하는 일련의 과정

- 데이터: 프로그램이 처리해야 할 정보
- 알고리즘: 데이터를 처리하는 절차나 방법

### 다양한 언어

- Python: 인공지능(AI) 및 데이터 과학에 주로 사용
- Java: 웹 및 엔터프라이즈 애플리케이션 개발에 많이 사용
- C#: 마이크로소프트(MS) 플랫폼을 위한 개발에 사용
- Go: 구글에서 개발한 언어로, 높은 성능과 간결함을 목표로 함
- C: 구조적 프로그래밍에 주로 사용
- C++: 객체지향 프로그래밍에 주로 사용

# 1-2 컴파일과 컴파일러 사용법

## 컴파일 과정

프로그래밍 언어로 작성된 소스 코드 → 기계어 

### 1. 전처리 (Preprocessing)

전처리기는 소스 코드에서 전처리 지시문(#으로 시작하는 지시문)을 처리합니다. 이 과정에서 파일을 포함(#include), 매크로를 정의(#define), 조건부 컴파일(#ifdef, #ifndef) 등의 작업이 수행됩니다. 전처리 결과는 확장된 소스 코드입니다.

### 2. 컴파일 (Compilation)

컴파일러는 전처리된 소스 코드를 분석하여 중간 코드(intermediate code)나 어셈블리 코드(assembly code)를 생성합니다. 개체파일이 됨. cpu가 해석가능한 명령어로 이루어진 기계어 파일이지만, OS에 의해 실행되므로 개체 파일을 설치된 OS가 인식할 수 있는 실행 파일로 바꿔야함.

- **어휘 분석 (Lexical Analysis):** 소스 코드를 토큰(token)으로 분할합니다.
- **구문 분석 (Syntax Analysis):** 토큰의 구조를 검사하여 구문 트리(parse tree)를 생성합니다.
- **의미 분석 (Semantic Analysis):** 구문 트리를 기반으로 의미를 검사하고, 중간 코드를 생성합니다.

### 3. 최적화 (Optimization)

생성된 중간 코드나 어셈블리 코드는 최적화 과정을 거쳐 성능이 향상됩니다. 이 과정에서는 불필요한 코드가 제거되거나, 더 효율적인 코드로 대체됩니다. 최적화는 컴파일러의 선택적인 단계로, 다양한 최적화 기법이 적용될 수 있습니다.

### 4. 어셈블리 (Assembly)

어셈블러는 어셈블리 코드를 기계어로 변환합니다. 이 단계에서는 어셈블리 코드를 바이너리 코드로 변환하여 객체 파일(object file)을 생성합니다.

### 5. 링크 (Linking)

링커는 개체 파일에 startup code를 결합함. 여러 객체 파일과 라이브러리 파일을 결합하여 실행 파일(executable)을 생성합니다. 이 과정에서 각 객체 파일의 심볼(symbol)을 해석하고, 필요한 라이브러리를 포함시킵니다. 링크 과정은 다음과 같은 하위 단계를 포함합니다.

- **심볼 해결 (Symbol Resolution):** 각 객체 파일의 심볼을 해석하고, 참조된 모든 심볼이 정의되어 있는지 확인합니다.
- **재배치 (Relocation):** 각 객체 파일의 주소를 조정하여 실행 파일의 메모리 레이아웃을 결정합니다.


물론입니다! 아래는 위의 내용을 `README.md` 형식으로 정리한 문서입니다. 마크다운 스타일로 구성되어 있어 GitHub나 문서화 도구에서 바로 사용하실 수 있습니다.






---

# 📘 구현체에 정의된 동작과 C 표준의 다양한 동작 종류

## 🔍 구현체(Implementation)란?

> **구현체**란 특정 기능이나 동작을 **실제로 코드로 작성한 것**을 의미합니다.  
> 즉, 이론이나 설계를 실제로 동작하도록 만든 **구체적인 코드**입니다.

---

## 📌 1. 구현체의 의미

- **이론 → 설계 → 구현체**
- 실제 기능을 수행하는 코드
- 예시: `printf()`는 표준 함수지만, glibc, MSVCRT 등 **구현체**에 따라 실제 동작 방식이 달라질 수 있음

---

## 📌 2. `printf` 구현체 예시 (glibc)

```c
int printf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    int result = vfprintf(stdout, format, args);
    va_end(args);
    return result;
}
```

---

## 📌 3. 구현체의 다양한 사례

| 분류 | 예시 |
|------|------|
| 표준 라이브러리 | `glibc`, `libstdc++` |
| 운영체제 | Linux 커널, Windows NT |
| 프로토콜 | TCP/IP, HTTP 등 |
| 알고리즘 | 정렬, 탐색 알고리즘 등 |

---

## 📌 4. 구현체와 이식성의 관계

> **이식성(Portability)**: 다양한 플랫폼에서 수정 없이 프로그램이 동작할 수 있는 능력

- 표준 함수도 구현체에 따라 동작이 달라질 수 있음
- 구현체에 종속적인 코드는 **이식성**을 해칠 수 있음

---

## 📌 5. 구현체에 따라 달라질 수 있는 동작 예시

### ✅ `%n` 포맷

```c
printf("Hello%n", &count);
```

- Linux (glibc): ✅ 정상 동작
- Windows (MSVCRT): ❌ 비활성화

---

### ✅ 구조체의 `sizeof`

```c
struct Data { char a; int b; };
```

- GCC (x86): `8`
- ARM: `4` (패딩 처리 다름)

---

### ✅ 파일 경로 구분

| OS | 구분자 |
|----|--------|
| Windows | `\` |
| Unix/Linux | `/` |

---

### ✅ 시스템 콜 사용

| 함수 | 리눅스 | 윈도우 |
|------|--------|--------|
| `fork()` | ✅ | ❌ |
| `sleep()` | ✅ | ⛔ 다른 방식 필요 |

---

### ✅ 정수 타입 크기

| 타입 | x86 | x86_64 | ARM |
|------|-----|--------|------|
| `int` | 4B | 4B | 4B |
| `long` | 4B | 8B | 8B |

> 이식성을 위해 `stdint.h`의 `int32_t`, `uint64_t` 사용 권장

---

## 📌 6. 이식성 확보를 위한 팁

- `stdint.h` 사용
- OS별 매크로 분기 처리
- 시스템 콜 추상화
- 줄바꿈 문자, 경로 구분 등 OS 차이 대응

---

## 🔍 미지정 동작 (Unspecified Behavior)

> **C 표준에서 여러 결과 중 어느 하나로 동작할 수 있도록 허용**된 경우

### ✅ 특징

- **컴파일러마다 결과 다름**
- **에러 아님**, 하지만 결과는 예측 불가

---

### ✅ 예시

#### 1. 함수 인자 평가 순서

```c
int result = f1() + f2();  // 어느 함수가 먼저 실행될지 보장되지 않음
```

#### 2. 구조체 패딩

```c
struct Example { char a; int b; };
```

- GCC: 8바이트
- ARM: 4바이트

#### 3. `malloc(0)`

```c
void *ptr = malloc(0);
```

- GCC: 유효 포인터 반환
- MSVC: NULL 반환

---

## 🔍 정의되지 않은 동작 (Undefined Behavior)

> **C 표준에서 어떤 결과가 나올지 보장하지 않는 동작**

### ✅ 예시

- 배열 경계 초과
- 0으로 나누기
- NULL 포인터 역참조
- `signed int` 오버플로우
- 이중 `free()` 호출

### ✅ 위험성

- 예측 불가한 결과
- 보안 취약점 가능
- 컴파일러가 임의의 최적화 수행

---

## 🔧 UB 방지 방법

- `-fsanitize=undefined`, `-Wall` 옵션 사용
- 포인터, 배열 유효성 검증
- `assert()`로 코드 검증

---

## 🔍 로케일별 동작 (Locale-Specific Behavior)

> 언어/문화/국가에 따라 출력 형식, 문자열 비교 등이 달라질 수 있음

### ✅ 예시

#### 숫자 형식

```c
setlocale(LC_ALL, "en_US.UTF-8");  // 1,000
setlocale(LC_ALL, "fr_FR.UTF-8");  // 1 000
```

#### 문자열 비교

```c
strcoll("apple", "Banana");
```

- 미국 영어: 대문자 우선
- 독일어: 소문자 우선

---

## 🔍 공통 확장 (Common Extensions)

> **표준이 아닌** 널리 쓰이는 함수 (이식성 ↓)

### ✅ 예시

#### `getline()`

- Linux: ✅ 지원
- Windows: ❌ 지원하지 않음

#### `strdup()`

- 대부분의 Unix 계열: ✅ 지원
- Windows: ⛔ 헤더 추가 필요

---

## 📌 핵심 요약

| 분류 | 설명 | 주의점 |
|------|------|--------|
| 구현체 정의 동작 | 표준을 구현한 실제 코드 | OS, 컴파일러마다 차이 |
| 미지정 동작 | 여러 결과 중 하나 | 예측 불가, 이식성 ↓ |
| 정의되지 않은 동작 | 어떤 결과도 보장 X | 심각한 버그 발생 |
| 로케일별 동작 | 국가/언어별 차이 | 출력/비교 방식 다름 |
| 공통 확장 | 널리 쓰이지만 표준 아님 | 플랫폼 종속 위험 |

---
